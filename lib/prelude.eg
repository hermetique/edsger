import base

# basic combinators

a b instead ≡ b

a del ≡

a dup ≡ a a

a b swap ≡ b a

f function 1 rep ≡ f .
f function n integer rep ≡ f . f (n 1 -) rep

0 base ind function nat-rec ≡ base
n integer base ind function nat-rec ≡ (n 1 -) base ind nat-rec n ind .

# data types

data bool ≡ true | false
data pair ≡ fst snd ,
data option ≡ nothing | from-itself itself
data either ≡ from-left left | from-right right
data list ≡ nil | init last cons

# pretty printer

a integer show ≡ a number show ≡ a "" bytecode 21
a string show ≡ a

true show ≡ "true"
false show ≡ "false"

a b , show ≡ "(" a show ++ ", " ++ b show ++ ")" ++

nothing show ≡ "nothing"
a itself show ≡ a show " itself" ++

a left show ≡ a show " left" ++
a right show ≡ a show " right" ++

nil show ≡ "[]"
a b cons show ≡ a show " : " ++ b show ++

# map

nothing _ function map ≡ nothing
a itself f function map ≡ a f . itself

a left _ function map ≡ a left
a right f function map ≡ a f . right

a b , f function map ≡ a (b f .) ,

nil _ function map ≡ nil
a b cons f function map ≡ (a f map) (b f .) cons

# list operations

lcons ≡ nil swap cons swap ++

nil head ≡ "head of empty list" fail
nil a cons head ≡ a
a b cons head ≡ a head

nil tail ≡ "tail of empty list" fail
nil a cons tail ≡ nil
a b cons tail ≡ a tail b cons

# packing and unpacking strings

"" →list ≡ nil
a string →list ≡ (a init →list) (a last) cons

nil →string ≡ ""
(a b string cons) →string ≡ a →string b ++

# predicates

false not ≡ true
true not ≡ false

true true and ≡ true
_ bool _ bool and ≡ false

false false or ≡ false
_ bool _ bool or ≡ true

# equality

for _ number _ number | _ string _ string
  = ≡ cmp λ 0 → true; _ → false

true true = ≡ false false = ≡ true
true false = ≡ false true = ≡ false

a b , c d , = ≡ (a c =) (b d =) and

a itself b itself = ≡ a b =
nothing nothing = ≡ true
_ itself nothing = ≡ nothing _ itself = ≡ false

a left b left = ≡ a right b right = ≡ a b =
_ left _ right = ≡ _ right _ left = ≡ false

nil nil = ≡ true
nil _ _ cons = ≡ _ _ cons nil = ≡ false
a b cons c d cons = ≡ (b d =) (a c =) and

/= ≡ = not

# ordering

a number b number < ≡ a b bytecode 20; λ -1 → true; _ → false

a string b string < ≡ a b cmp λ -1 → true; _ → false

a b > ≡ a b < not a b = not and

# conditionals

true b function c function ite ≡ b .
false b function c function ite ≡ c .

a b function when ≡ a b [] ite

a b function unless ≡ a [] b ite

# filter

nil f function filter ≡ nil
a b cons f function filter ≡ a f filter b f . [b cons] when

# semigroup

for _ string _ string
  <> ≡ ++

for _ number _ number
  <> ≡ +

a function b function <> ≡ [a . b .]

for _ bool _ bool
  <> ≡ or

nothing nothing <> ≡ nothing _ itself <> ≡ _ itself nothing <> ≡ nothing
a itself b itself <> ≡ a b <> itself

a left _ <> ≡ _ a left <> ≡ a left
a right b right <> ≡ a b <> right

(a b ,) (c d ,) <> ≡ (a c <>) (b d <>) ,

nil a <> ≡ a nil <> ≡ a
a (b c cons) <> ≡ (a b <>) c cons 

# monoids

data mempty

mempty a ++ ≡ a mempty ++ ≡ a

for _ number _ number | _ function _ function | _ bool _ bool | _ pair _ pair | _ list _ list
  ++ ≡ <>

# folds/foldable

nil a f function foldr ≡ a
t h cons a f function foldr ≡ t (h a f .) f foldr

nil a f function foldl ≡ a
t h cons a f function foldl ≡ (t a f foldl) h f .

"" a f function foldr ≡ a
s string a f function foldr ≡ s init (s last a f .) f foldr

"" a f function foldl ≡ a
s string a f function foldl ≡ (s init a f foldl) s last f .

concat ≡ mempty [++] foldr

length ≡ 0 [1 + instead] foldr

nil _ intersperse ≡ nil
nil a cons _ intersperse ≡ nil a cons
(a b cons) c intersperse ≡ (a c intersperse) c cons b cons

intercalate ≡ intersperse concat

a list unpack ≡ a go a length where
  nil go ≡ 
  a b cons go ≡ a go b

for _ list
  reverse ≡ unpack λ len → nil [swap cons] len rep where
