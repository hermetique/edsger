import prelude

data leaf | _ _ node-value _ node

# combinator for traversing dictionaries
# a = value to return at leaf nodes (key not found)
# k = key to operate on
# f = function to apply when key is found

leaf a k f dict-rec ≡ a
(l k' a' r node) a k f dict-rec ≡
  k' k = λ true → l k' a' r node f .
           false → k' k > λ true → (l a k f dict-rec) k' a' r node
                            false → l k' a' (r a k f dict-rec) node

# insert

k a dict-insert ≡ (leaf k a leaf node) k [a ->node-value] dict-rec

leaf k a pair insert ≡ leaf k a dict-insert
(l k' a' r node) k a pair insert ≡ (l k' a' r node) k a dict-insert

# find

leaf k find ≡ nothing
(l k' a' r node) k find ≡
  k' k = λ true → a' itself
           false → k' k > λ true → l k find
                            false → r k find

# adjust and update

k f function dict-adjust ≡ leaf k [f <-node-value] dict-rec

leaf k f function adjust ≡ leaf k f dict-adjust
(l k' a r node) k f function adjust ≡ (l k' a r node) k f dict-adjust

a update ≡ [a instead] adjust

# construct

nil →dict ≡ leaf
t (k a pair) cons →dict ≡ (t →dict) k a insert

# map

leaf _ function map ≡ leaf
(l k a r node) f function map ≡ (l f map) k (a f .) (r f map) node
