import base

# basic combinators

a b instead ≡ b

a del ≡

a dup ≡ a a

a b swap ≡ b a

f function 1 rep ≡ f .
f function n integer rep ≡ f . f (n 1 -) rep

0 base ind function nat-rec ≡ base
n integer base ind function nat-rec ≡ (n 1 -) base ind nat-rec n ind .

a b f function to-both ≡ (a f .) (b f .)

# data types

data list ≡ nil | init last cons
data ordering ≡ LT | EQ | GT
data bool ≡ true | false
data pair ≡ fst snd ,
data labelled ≡ _ _ :
data option ≡ nothing | from-itself itself
data either ≡ from-left left | from-right right

# to and from primitive (autogeneratd once deriving works)

nil "true" : primitive→ ≡ true
nil "false" : primitive→ ≡ false

nil "nothing" : primitive→ ≡ nothing
nil a cons "itself" : primitive→ ≡ a itself

nil a cons "left" : primitive→ ≡ a left
nil a cons "right" : primitive→ ≡ a right

nil a cons b cons "," : primitive→ ≡ a b ,

true →primitive ≡ nil "true" :
false →primitive ≡ nil "false" :

nothing →primitive ≡ nil "nothing" :
a itself →primitive ≡ nil a cons "itself" :

a left →primitive ≡ nil a cons "left" :
a right →primitive ≡ nil a cons "right" :

a b , →primitive ≡ nil a cons b cons "," :

# pretty printer, literal values

a integer show ≡ a number show ≡ a "" bytecode 21
a string show ≡ a

# pretty printer, derived implementations

nil show ≡ "nil"
a b : show ≡ "(" a show ++ " " ++ b ++ ")" ++
a b cons show ≡ a show " " ++ b show ++

for _ bool | _ option | _ either | _ pair
  show ≡ →primitive show

# map, derived implementations

nil _ function map ≡ nil
a b cons f function map ≡ a f map (b f .) cons
a b : f function map ≡ a f map b : primitive→

for _ option | _ either | _ pair
  f function map ≡ →primitive f map

# list operations

lcons ≡ nil swap cons swap ++

nil head ≡ "head of empty list" fail
nil a cons head ≡ a
a b cons head ≡ a head

nil tail ≡ "tail of empty list" fail
nil a cons tail ≡ nil
a b cons tail ≡ a tail b cons

# packing and unpacking strings

"" →list ≡ nil
a string →list ≡ (a init →list) (a last) cons

nil →string ≡ ""
(a b string cons) →string ≡ a →string b ++

# predicates

false not ≡ true
true not ≡ false

true true and ≡ true
_ bool _ bool and ≡ false

false false or ≡ false
_ bool _ bool or ≡ true

# conditionals

true b function c function ite ≡ b .
false b function c function ite ≡ c .

a b function when ≡ a b [] ite

a b function unless ≡ a [] b ite

# equality, literals

for _ number _ number | _ string _ string
  = ≡ cmp λ 0 → true; _ → false

# equality, derived implementations

a b : c d : = ≡ b d = [a c =] [false] ite
nil nil = ≡ true
nil _ _ cons = ≡ _ _ cons nil = ≡ false
a b cons c d cons = ≡ b d = [a c =] [false] ite

for _ bool _ bool | _ option _ option | _ either _ either | _ pair _ pair
  = ≡ [→primitive] to-both =

for _ _
  /= ≡ = not

# ordering

compare ≡ cmp λ -1 → LT; 0 → EQ; 1 → GT; _ → "cmp failed" fail

for _ number _ number | _ string _ string
  < ≡ compare λ LT → true; _ → false

a b > ≡ a b < not a b = not and

# filter

nil f function filter ≡ nil
a b cons f function filter ≡ a f filter b f . [b cons] when

# semigroup, literals

for _ string _ string
  <> ≡ ++

for _ number _ number
  <> ≡ +

a function b function <> ≡ [a . b .]

for _ bool _ bool
  <> ≡ or

nothing nothing <> ≡ nothing _ itself <> ≡ _ itself nothing <> ≡ nothing
a itself b itself <> ≡ a b <> itself

a left _ <> ≡ _ a left <> ≡ a left
a right b right <> ≡ a b <> right

(a b ,) (c d ,) <> ≡ (a c <>) (b d <>) ,

nil a <> ≡ a nil <> ≡ a
a (b c cons) <> ≡ (a b <>) c cons 

# monoids

data mempty

mempty a ++ ≡ a mempty ++ ≡ a

for _ number _ number | _ function _ function | _ bool _ bool | _ pair _ pair | _ list _ list
  ++ ≡ <>

# folds/foldable

nil a f function foldr ≡ a
t h cons a f function foldr ≡ t (h a f .) f foldr

nil a f function foldl ≡ a
t h cons a f function foldl ≡ (t a f foldl) h f .

"" a f function foldr ≡ a
s string a f function foldr ≡ s init (s last a f .) f foldr

"" a f function foldl ≡ a
s string a f function foldl ≡ (s init a f foldl) s last f .

concat ≡ mempty [++] foldr

length ≡ 0 [1 + instead] foldr

nil _ intersperse ≡ nil
nil a cons _ intersperse ≡ nil a cons
(a b cons) c intersperse ≡ (a c intersperse) c cons b cons

intercalate ≡ intersperse concat

a list unpack ≡ (a go) (a length) where
  nil go ≡ 
  a b cons go ≡ a go b

for _ list
  reverse ≡ unpack λ len → nil [swap cons] len rep where
