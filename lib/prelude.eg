import base

# basic combinators

a b instead ≡ b

a del ≡

a dup ≡ a a

a b swap ≡ b a

f function 1 rep ≡ f .
f function n integer rep ≡ f . f n 1 - rep

0 base ind function nat-rec ≡ base
n integer base ind function nat-rec ≡ [n 1 -] base ind nat-rec n ind .

# data types

data true | false
data fst snd pair
data nothing | from-itself itself
data from-left left | from-right right
data nil | init last cons

# pretty printer

a integer show ≡ a number show ≡ a "" bytecode 21
a string show ≡ a

true show ≡ "true"
false show ≡ "false"

a b pair show ≡ "(" a show ++ ", " ++ b show ++ ")" ++

nothing show ≡ "nothing"
a itself show ≡ a show " itself" ++

a left show ≡ a show " left" ++
a right show ≡ a show " right" ++

nil show ≡ "[]"
a b cons show ≡ a show " : " ++ b show ++

# map

nothing _ function map ≡ nothing
a itself f function map ≡ a f . itself

a left _ function map ≡ a left
a right f function map ≡ a f . right

nil _ function map ≡ nil
a b cons f function map ≡ a f map b f . cons

# list operations

lcons ≡ nil swap cons swap ++

nil head ≡ "head of empty list" fail
nil a cons head ≡ a
a b cons head ≡ a head

nil tail ≡ "tail of empty list" fail
nil a cons tail ≡ nil
a b cons tail ≡ a tail b cons

# predicates

false not ≡ true
true not ≡ false

true true and ≡ true
_ _ and ≡ false

false false or ≡ false
_ _ or ≡ true

# equality

a number b number = ≡ a b bytecode 20; cmp->bool where
  0 cmp->bool ≡ true
  _ cmp->bool ≡ false

true true = ≡ false false = ≡ true
true false = ≡ false true = ≡ false

a b pair c d pair = ≡ a c = b d = and

a itself b itself = ≡ a b =
nothing nothing = ≡ true
_ itself nothing = ≡ nothing _ itself = ≡ false

a left b left = ≡ a right b right = ≡ a b =
_ left _ right = ≡ _ right _ left = ≡ false

nil nil = ≡ true
nil _ _ cons = ≡ _ _ cons nil = ≡ false
a b cons c d cons = ≡ b d = a c = and

/= ≡ = not

# ordering

a number b number < ≡ a b bytecode 20; cmp->bool where
  -1 cmp->bool ≡ true
  _ cmp->bool ≡ false

a b > ≡ a b < not a b = not and

# conditionals

true b function c function ite ≡ b .
false b function c function ite ≡ c .

a b function when ≡ a b () ite

a b function unless ≡ a () b ite

# filter

nil f function filter ≡ nil
a b cons f function filter ≡ a f filter b f . (b cons) when

# monoids

data mempty

mempty a ++ ≡ a mempty ++ ≡ a

a number b number ++ ≡ a b +

a function b function ++ ≡ (a . b .)

a b pair c d pair ++ ≡ a c ++ b d ++ pair

nothing nothing ++ ≡ nothing _ itself ++ ≡ _ itself nothing ++ ≡ nothing
a itself b itself ++ ≡ a b ++ itself

nil a ++ ≡ a nil ++ ≡ a
a b c cons ++ ≡ a b ++ c cons

# folds/foldable

nil a f function foldr ≡ a
t h cons a f function foldr ≡ t [h a f .] f foldr

nil a f function foldl ≡ a
t h cons a f function foldl ≡ [t a f foldl] h f .

concat ≡ mempty (++) foldr

# traversable

nil reverse ≡ nil
a b cons reverse ≡ nil b cons a reverse ++

nil _ intersperse ≡ nil
nil a cons _ intersperse ≡ nil a cons
a b cons c intersperse ≡ a c intersperse c cons b cons

intercalate ≡ intersperse concat
