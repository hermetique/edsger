import prelude

data _ _ expr

s parenthesize ≡ "{\\left(" s ++ "\\right)}" ++
(val old-lvl expr) new-lvl wrap ≡ (val show) old-lvl new-lvl > [parenthesize] when

a number latex ≡ a string latex ≡ a 0 expr
a _ expr show ≡ a show

# combinator for binary operators, enforces precedence

a b name lvl binop ≡ (a lvl wrap) name ++ (b lvl wrap) ++ lvl expr

# arithmetic

for _ _ expr _ _ expr
  + ≡ "+" 60 binop
  - ≡ "-" 60 binop
  * ≡ "\\cdot " 50 binop
  = ≡ "=" 100 binop
  lt ≡ "<" 70 binop
  gt ≡ ">" 70 binop
  le ≡ "\\le " 70 binop
  ge ≡ "\\ge " 70 binop
  , ≡ "," 70 binop

a _ expr c _ expr / ≡ "\\frac{" a show ++ "}{" ++ c show ++ "}" ++ 0 expr

c _ expr . ≡ λ a _ expr → c a parenthesize ++ 50 expr

a b expr abs ≡ "{\\left|" a show ++ "\\right|}" ++ 0 expr
a b expr norm ≡ "{\\lVert " a show ++ "\\rVert}" ++ 0 expr

a _ expr c _ expr ^ ≡ "{" a show ++ "}^{" ++ c show ++ "}" ++ 0 expr
a b expr c _ expr int ≡ "\\int " a b expr 50 wrap ++ "~\\mathrm{d}" ++ c show ++ 50 expr
a b expr c _ expr der ≡ "\\frac{\\mathrm{d}}{\\mathrm{d}" c show ++ "}" ++ a b expr 50 wrap ++ 50 expr

l (n _ expr) cases ≡ (nil l cons) (n 1 -) cases' 90 expr where
  l 0 cases' ≡ "\\begin{cases}" l [show] map "\\\\" intercalate ++ "\\end{cases}" ++
  l n cases' ≡ λ case → l case lcons n 1 - cases'
